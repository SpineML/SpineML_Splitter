
#include <iostream>
#include <QDebug>


#include "aliaswriter.h"
#include "splitter.h"

#define MAX_PROJ_INPUTS 80
//#define INPUTS_PER_PORT 80
//#define MAX_INPUT_PORTS 80
//#define MAX_POP_SIZE 100




DamsonAliasWriter::DamsonAliasWriter(QString output_filename, InfoParser *info, Experiment *experiment)
    : SpineMLWriter(output_filename)
{
    out.setDevice(output_file);
    this->info = info;
    this->experiment = experiment;
}

void DamsonAliasWriter::writeDocumentStart()
{
    out << "// DAMSON ALIAS FILE GENERATED BY SPINEML SPLITTER" << endl << endl << endl;
}

void DamsonAliasWriter::writeDocuemntEnd()
{
    out << "// END OF DAMSON ALIAS FILE" << endl;
}

void DamsonAliasWriter::writePopulation(Population *sub_population, Population *population)
{
    //unsplit info
    PopulationInfo *unsplit_pop_info = info->getUnsplitPopulationInfo(sub_population->neuron->name);
    QString unsplit_neuron_name = unsplit_pop_info->name;

    //alias name and pop size
    QString alias_name_sanitized = sanitizeName(population->neuron->name, "o");
    uint sub_pop_index = info->getSubPopulationIndex(sub_population->neuron->name);
    uint alias_num = unsplit_pop_info->global_sub_start_index+sub_pop_index;
    out << "// ALIAS " << sub_population->neuron->name << " " << alias_num << endl;
    out << "#alias " << alias_name_sanitized << " " << alias_num << endl << endl;
    out << "num_neurons_actual = " << sub_population->neuron->size << ";" << endl << endl;

    //hash tables
    writeHashTableData(sub_population, population);

    // open used output ports (neuron only)
    writeActivePortsData(unsplit_neuron_name);

    //write explicit list paramaters and state variables (neuron)
    writeAllExplicitNeuronPropertyData(sub_population, unsplit_neuron_name);

    //write explicit list paramaters and state variables (post synapse)
    writeAllExplicitPSPropertyData(sub_population, unsplit_neuron_name);

    //write explicit list paramaters and state variables (weightupdate) properties are in an array of max splits
    writeAllExplicitWUPropertyData(sub_population, population);

    //write explicit synapse connections (connections and delays)
    writeAllExplicitSynapseData(sub_population, population);

    //write explicit generic input connections for neuron (connection and delay)
    writeAllExplicitNeuronInputData(sub_population, population);

    //TODO write explicit generic input connections for psp (connection and delay)

    //interrupts (TODO INPUT NODES TO PSP (IGNORE SELF CONNECTIONS))
    writeInterruptData(sub_population);

    //write log outputs
    writeLogOutputData(sub_population, population, experiment);



    out << endl << endl;

}

void DamsonAliasWriter::writeHashTableData(Population* sub_population, Population *population)
{
    uint sub_pop_index = info->getSubPopulationIndex(sub_population->neuron->name);

    // data for hash tables (INPUT ROWS TO WEIGHTUPDATE not supported)
    QHash <int, DAMSONInputHash> inputs;
    QList <DAMSONInputHash> ordered_inputs;
    out << "hashCreation = {" << endl;

    //same loops as writing the synapse data
    //iterate the unsplit synapses and look for projections that exist (some may not depending on connectivity): This preserves the order!

    //projection/synapse connectivity
    for (int p=0; p<population->projections.values().size();p++ ){
        Projection *projection = population->projections.values()[p];
        PopulationInfo *proj_target_info = info->getPopulationInfo(projection->proj_population);
        uint proj_target_size = proj_target_info->size;
        uint proj_target_sub_count = UINT_DIV_CEIL(proj_target_size, MAX_POPULATION_SIZE);
        for(int s=0; s<projection->synapses.values().size(); s++){
            Synapse* synapse = projection->synapses.values()[s];
            uint sub_syn_rows = 0;  //this is our ordered index for unique sub population sources
            //iterate each possible sub projection: could do this slightly more efficiently using the known connectivity pattern but this is fine
            for(uint d=0;d<proj_target_sub_count; d++){
                QString sub_proj_name = "%1_sub%2";
                sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);
                //does the possible sub projection exist?
                if (sub_population->projections.contains(sub_proj_name)){ //may or may not be a sub projection depending on connectivity
                    Projection* sub_projection = sub_population->projections[sub_proj_name];
                    //get the sub synapse
                    QString sub_syn_name = "%1_sub%2_%3";
                    sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                    Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                    errorCheckSynapse(synapse, sub_synapse, sub_syn_name);                      //some error checking on sub synapse
                    DAMSONInputHash h;
                    uint proj_src_sub_index = info->getSubPopulationIndex(sub_projection->proj_population);
                    uint proj_src_alias = proj_target_info->global_sub_start_index+proj_src_sub_index;
                    h.src_node_number = proj_src_alias;
                    h.src_switch_value = proj_target_info->global_index;
                    h.src_split_index = sub_syn_rows++;
                    //add the hash table entry
                    if (!inputs.contains(h.src_node_number)){
                        inputs[h.src_node_number] = h;
                    }else{
                        DAMSONInputHash existing_h = inputs[h.src_node_number];
                        if ((h.src_split_index != existing_h.src_split_index)||(h.src_switch_value != existing_h.src_switch_value)){
                            qDebug() << "Alias Writer Internal Error: Multiple synapses with different connectivity types not yet supported!";
                            exit(0);
                        }
                    }

                }
            }
        }
    }

    //input rows to neuron
    for (int i=0; i<population->neuron->inputs.values().size();i++ ){
            Input *unsplit_input = population->neuron->inputs.values()[i];
            PopulationInfo *input_src_info = info->getPopulationInfo(unsplit_input->src);
            uint input_src_size = input_src_info->size;
            uint input_src_sub_count = UINT_DIV_CEIL(input_src_size, MAX_POPULATION_SIZE);
            uint sub_inp_rows = 0;   //this is our ordered index for unique sub population sources
            for(uint d=0;d<input_src_sub_count; d++){
                QString sub_inp_name = "%1_%2_%3_sub%4";
                sub_inp_name = sub_inp_name.arg(unsplit_input->src).arg(unsplit_input->src_port).arg(unsplit_input->dst_port).arg(d);
                //does the possible sub input exist?
                if (sub_population->neuron->inputs.contains(sub_inp_name)){ //may or may not be a sub input depending on connectivity
                    Input* sub_input = sub_population->neuron->inputs[sub_inp_name];
                    DAMSONInputHash h;
                    uint input_src_sub_index = info->getSubPopulationIndex(sub_input->src);
                    uint input_src_alias = input_src_info->global_sub_start_index+input_src_sub_index;
                    h.src_node_number = input_src_alias;
                    h.src_switch_value = input_src_info->global_index;
                    h.src_split_index = sub_inp_rows++;
                    if (!inputs.contains(h.src_node_number)){
                        inputs[h.src_node_number] = h;
                    }else{
                        DAMSONInputHash existing_h = inputs[h.src_node_number];
                        if ((h.src_split_index != existing_h.src_split_index)||(h.src_switch_value != existing_h.src_switch_value)){
                            qDebug() << "Alias Writer Internal Error: Multiple synapses with different connectivity types not yet supported!";
                            exit(0);
                        }
                    }

                }
        }
    }

    //input rows to post synapse
    for (int p=0; p<population->projections.values().size();p++ ){
        Projection *projection = population->projections.values()[p];
        ComponentInfo *proj_target_info = info->getComponentInfo(projection->proj_population);

        //target is the named src or dst of the projection
        uint proj_target_size = proj_target_info->size;
        uint proj_target_sub_count = UINT_DIV_CEIL(proj_target_size, MAX_POPULATION_SIZE);
        for(int s=0; s<projection->synapses.values().size(); s++){
            Synapse* synapse = projection->synapses.values()[s];

            for (int i=0; i<synapse->postsynapse->inputs.values().size();i++ ){
                Input *unsplit_input = synapse->postsynapse->inputs.values()[i];
                if (!((unsplit_input->src == population->neuron->name)&&(unsplit_input->remapping->Type() == ONE_TO_ONE_CONNECTVITY_TYPE))){ //ignore one to one inputs from self (handled internally)
                    PopulationInfo *input_src_info = info->getPopulationInfo(unsplit_input->src);
                    uint input_src_size = input_src_info->size;
                    uint input_src_sub_count = UINT_DIV_CEIL(input_src_size, MAX_POPULATION_SIZE);
                    uint sub_inp_rows = 0;
                    //find first sub projection to the sub population (only need the first as psps and any inputs are duplicated for any sub projection to this sub population)
                    for(uint d=0;d<proj_target_sub_count; d++){
                        QString sub_proj_name = "%1_sub%2";
                        sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);
                        //does the sub projection exist?
                        if (sub_population->projections.contains(sub_proj_name)){
                            Projection* sub_projection = sub_population->projections[sub_proj_name];
                            QString sub_syn_name = "%1_sub%2_%3";
                            sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                            Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                            errorCheckSynapse(synapse, sub_synapse, sub_syn_name); //some error checking on sub synapse
                            for(uint d=0;d<input_src_sub_count; d++){
                                QString sub_inp_name = "%1_%2_%3_sub%4";
                                sub_inp_name = sub_inp_name.arg(unsplit_input->src).arg(unsplit_input->src_port).arg(unsplit_input->dst_port).arg(d);
                                //does the sub input exist
                                if (sub_synapse->postsynapse->inputs.contains(sub_inp_name)){ //may or may not be a sub input depending on connectivity
                                    Input* sub_input = sub_synapse->postsynapse->inputs[sub_inp_name];
                                    DAMSONInputHash h;
                                    uint input_src_sub_index = info->getSubPopulationIndex(sub_input->src);
                                    uint input_src_alias = input_src_info->global_sub_start_index+input_src_sub_index;
                                    h.src_node_number = input_src_alias;
                                    h.src_switch_value = input_src_info->global_index;
                                    h.src_split_index = sub_inp_rows++;
                                    if (!inputs.contains(h.src_node_number)){
                                        inputs[h.src_node_number] = h;
                                    }else{
                                        DAMSONInputHash existing_h = inputs[h.src_node_number];
                                        if ((h.src_split_index != existing_h.src_split_index)||(h.src_switch_value != existing_h.src_switch_value)){
                                            qDebug() << "Alias Writer Internal Error: Multiple synapses with different connectivity types not yet supported!";
                                            exit(0);
                                        }
                                    }
                                }
                            }
                            //only need one sub projection as they all contain the same duplicated psp
                            break;
                        }
                    }
                }
            }
        }
    }


    //Check max proj inputs
    if (inputs.keys().size()>MAX_PROJ_INPUTS){
        std::cerr << "Error: DAMSON alias writer hash_creation rows exceed for '" << sub_population->neuron->name.toLocal8Bit().data() << "'" << std::endl;
        exit(0);
    }
    //write inputs in order (for easier human readability)
    ordered_inputs = inputs.values();
    qSort(ordered_inputs.begin(), ordered_inputs.end());
    for (int i=0; i<ordered_inputs.size(); i++){
        QString end_comma;  //if not last entry
        if (i != MAX_PROJ_INPUTS)
            end_comma = ",";
        //{src_node_number, src_switch_value, src_split_index}
        //TODO: Suggested future format us src_node_number(alias number), src_switch_value(unsplit population index), src_sub_pop_index, src_connection_index (what was src_split_index but unique for each synapse or input)
        out << "\t" << ordered_inputs.at(i).toString() << end_comma << endl;
    }
    //padding
    for(int i=ordered_inputs.size(); i<MAX_PROJ_INPUTS; i++){
        QString end_comma;  //if not last entry
        if ((i+1) != MAX_PROJ_INPUTS)
            end_comma = ",";
        out << "\t{0,0,0}" << end_comma << endl;
    }
    out << "};" << endl << endl;
    inputs.clear();
    ordered_inputs.clear();
}

void DamsonAliasWriter::writeActivePortsData(QString unsplit_neuron_name)
{
    QSet<QString> active_ports = QSet<QString>::fromList(info->getActiveSourcePorts(unsplit_neuron_name));
    //loop through unique active ports
    for (int i=0;i<active_ports.values().size(); i++){
        out << "portOn_" << active_ports.values().at(i) << " = 1;" << endl;
    }
    out << endl;
}

void DamsonAliasWriter::writeAllExplicitNeuronPropertyData(Population *sub_population, QString unsplit_neuron_name)
{
    for(int p=0; p< sub_population->neuron->properties.size(); p++){
        Property* sub_prop = sub_population->neuron->properties.at(p);
        if (sub_prop->value->Type() == VALUE_LIST_TYPE){
            PropertyValueList* value_list = (PropertyValueList*)sub_prop->value;
            QString alias_prop_name = "%1%2";
            alias_prop_name = alias_prop_name.arg(sub_prop->name, unsplit_neuron_name);
            alias_prop_name = sanitizeName(alias_prop_name);
            out << alias_prop_name << " = {" << endl << "\t";
            for (uint v=0; v<MAX_POPULATION_SIZE; v++){
                if (value_list->valueInstances.contains(v)){
                    PropertyValueInstance* val = value_list->valueInstances[v];
                    out << val->value;
                }else if (sub_population->neuron->size <= v){
                    out << "0";
                }else{
                    std::cerr << "Alias Writer Error: Incomplete explicit list property data for neuron '" << unsplit_neuron_name.toLocal8Bit().data() << "' property '" <<  sub_prop->name.toLocal8Bit().data() << "'" << std::endl;
                    exit(0);
                }
                if (v == (MAX_POPULATION_SIZE-1))
                    out << endl;
                else
                    out << ", ";
            }
            out << "};" << endl << endl;
        }
    }
}

void DamsonAliasWriter::writeAllExplicitPSPropertyData(Population *sub_population, QString unsplit_neuron_name)
{
    QSet <QString>unique_strings;

    for (int p=0; p<sub_population->projections.values().size();p++ ){
        Projection *sub_proj = sub_population->projections.values()[p];
        for(int s=0; s<sub_proj->synapses.values().size(); s++){
            Synapse* sub_syn = sub_proj->synapses.values()[s];
            for (int i=0; i<sub_syn->postsynapse->properties.size(); i++){
                Property* ps_prop = sub_syn->postsynapse->properties.at(i);
                if (ps_prop->value->Type() == VALUE_LIST_TYPE){
                    QString alias_ps_prop_name = "%1%2";
                    alias_ps_prop_name = alias_ps_prop_name.arg(ps_prop->name, unsplit_neuron_name);
                    alias_ps_prop_name = sanitizeName(alias_ps_prop_name);
                    //post synapses are duplicated so only write the property once
                    if (!unique_strings.contains(alias_ps_prop_name)){
                        PropertyValueList* value_list = (PropertyValueList*)ps_prop->value;
                        out << alias_ps_prop_name << " = {" << endl << "\t";
                        for (uint v=0; v<MAX_POPULATION_SIZE; v++){
                            if (value_list->valueInstances.contains(v)){
                                PropertyValueInstance* val = value_list->valueInstances[v];
                                out << val->value;
                            }else if (sub_population->neuron->size <= v){
                                out << "0";
                            }else{
                                std::cerr << "Alias Writer Error: Incomplete explicit list property data for postsynpase '" << unsplit_neuron_name.toLocal8Bit().data() << "' property '" <<  ps_prop->name.toLocal8Bit().data() << "'" << std::endl;
                                exit(0);
                            }
                            if (v == (MAX_POPULATION_SIZE-1))
                                out << endl;
                            else
                                out << ", ";
                        }
                        out << "};" << endl << endl;
                        unique_strings.insert(alias_ps_prop_name); //dont duplicate this property
                    }
                }
            }

        }
    }
}

void DamsonAliasWriter::writeAllExplicitWUPropertyData(Population *sub_population, Population *population)
{
    uint sub_pop_index = info->getSubPopulationIndex(sub_population->neuron->name);

    for (int p=0; p<population->projections.values().size();p++ ){
        Projection *projection = population->projections.values()[p];
        ComponentInfo *target_info = info->getComponentInfo(projection->proj_population);

        //target is the named src or dst of the projection
        uint proj_target_size = target_info->size;
        uint proj_target_sub_count = UINT_DIV_CEIL(proj_target_size, MAX_POPULATION_SIZE);
        for(int s=0; s<projection->synapses.values().size(); s++){
            Synapse* synapse = projection->synapses.values()[s];
            //get property name
            for (int i=0; i< synapse->weightupdate->properties.size(); i++){
                Property* property = synapse->weightupdate->properties[i];
                if (property->value->Type() == VALUE_LIST_TYPE){
                    QString alias_wu_prop_name = "%1%2";
                    alias_wu_prop_name = alias_wu_prop_name.arg(property->name, synapse->weightupdate->name);
                    alias_wu_prop_name = sanitizeName(alias_wu_prop_name);
                    out << alias_wu_prop_name << " = {" << endl;
                    switch(synapse->connection->Type()){                     //switch by connectivity type
                        case(ONE_TO_ONE_CONNECTVITY_TYPE):{
                            QString sub_proj_name = "%1_sub%2";
                            sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(sub_pop_index);
                            //get the sub projection
                            Projection* sub_projection = sub_population->projections[sub_proj_name];
                            if (!sub_projection){
                                qDebug() << "Internal error: missing one to one projection '" << sub_proj_name << "' in sub population '" << sub_population->neuron->name << "'";
                                exit(0);
                            }
                            //get the sub synapse
                            QString sub_syn_name = "%1_sub%2_%3";
                            sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(sub_pop_index);
                            Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                            //some error checking on sub synapse
                            errorCheckSynapse(synapse, sub_synapse, sub_syn_name);

                            //write single property row
                            Property* wu_prop = sub_synapse->weightupdate->properties.at(i);
                            PropertyValueList* value_list = (PropertyValueList*)wu_prop->value; //assume its the same type (this is a pretty safe assumption!)
                            out << openSubArray(1);
                            for (uint v=0; v<MAX_POPULATION_SIZE; v++){
                                if (value_list->valueInstances.contains(v)){
                                    PropertyValueInstance* val = value_list->valueInstances[v];
                                    out << arrayValue(val->value, v, MAX_POPULATION_SIZE);
                                }else if (sub_population->neuron->size <= v){
                                    out << arrayValue("0", v, MAX_POPULATION_SIZE);
                                }else{
                                    std::cerr << "Alias Writer Error: Incomplete explicit list property data for one to one weightupdate '" << sub_syn_name.toLocal8Bit().data() << "' property '" <<  wu_prop->name.toLocal8Bit().data() << "'" << std::endl;
                                    exit(0);
                                }
                            }
                            out << closeSubArray(0, 0, 1) << endl;

                            break;
                        }
                        case(ALL_TO_ALL_CONNECTVITY_TYPE):{
                            for(uint d=0;d<proj_target_sub_count; d++){
                                QString sub_proj_name = "%1_sub%2";
                                sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);
                                uint proj_target_sub_size = MAX_POPULATION_SIZE;
                                if (d == (proj_target_sub_count-1)){
                                    uint r = proj_target_size % MAX_POPULATION_SIZE;
                                    if (r != 0)
                                        proj_target_sub_size = r;
                                }
                                //get the sub projection
                                Projection* sub_projection = sub_population->projections[sub_proj_name];
                                if (!sub_projection){
                                    qDebug() << "Internal error: missing all to all projection '" << sub_proj_name << "' in sub population '" << sub_population->neuron->name << "'";
                                    exit(0);
                                }
                                //get the sub synapse
                                QString sub_syn_name = "%1_sub%2_%3";
                                sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                                Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                                //some error checking on sub synapse
                                errorCheckSynapse(synapse, sub_synapse, sub_syn_name);

                                Property* wu_prop = sub_synapse->weightupdate->properties.at(i);
                                PropertyValueList* value_list = (PropertyValueList*)wu_prop->value; //assume its the same type (this is a pretty safe assumption!)
                                out << openSubArray(1) << endl;
                                for (uint x=0; x<MAX_POPULATION_SIZE; x++){ //dst neurons
                                    out << openSubArray(2);
                                    for (uint y=0; y<MAX_POPULATION_SIZE; y++){ //src neurons
                                        uint index = (x*sub_population->neuron->size) + y;
                                        if (sub_population->neuron->size<= y){
                                            out << "0";
                                        }else if (value_list->valueInstances.contains(index)){
                                            PropertyValueInstance* val = value_list->valueInstances[index];
                                            out << arrayValue(val->value, y, MAX_POPULATION_SIZE);
                                        }else if (proj_target_sub_size <= x){
                                            out << arrayValue("0", y, MAX_POPULATION_SIZE);
                                        }else{
                                            std::cerr << "Alias Writer Error: Incomplete explicit list property data for all to all weightupdate '" << sub_syn_name.toLocal8Bit().data() << "' property '" <<  wu_prop->name.toLocal8Bit().data() << "'" << std::endl;
                                            exit(0);
                                        }
                                    }
                                    out << closeSubArray(0, x, MAX_POPULATION_SIZE) << endl;
                                }
                                out << closeSubArray(1, d, proj_target_sub_count) << endl;
                            }
                            break;
                        }
                        case(LIST_CONNECTVITY_TYPE):{
                            uint sub_syn_rows = 0;
                            for(uint d=0;d<proj_target_sub_count; d++){
                                QString sub_proj_name = "%1_sub%2";
                                sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);

                                //get the sub projection
                                if (sub_population->projections.contains(sub_proj_name)){ //may or may not be a sub projection depending on connectivity
                                    Projection* sub_projection = sub_population->projections[sub_proj_name];
                                    //get the sub synapse
                                    QString sub_syn_name = "%1_sub%2_%3";
                                    sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                                    Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                                    //some error checking on sub synapse
                                    errorCheckSynapse(synapse, sub_synapse, sub_syn_name);

                                    Property* wu_prop = sub_synapse->weightupdate->properties.at(i);
                                    PropertyValueList* value_list = (PropertyValueList*)wu_prop->value; //assume its the same type (this is a pretty safe assumption!)

                                    //itterate all possible connections and delay value
                                    ConnectionList* connection_list = (ConnectionList*)sub_synapse->connection;
                                    out << openSubArray(1) << endl;
                                    for (uint y=0; y<MAX_POPULATION_SIZE; y++){
                                        out << openSubArray(2);
                                        for (uint x=0; x<MAX_POPULATION_SIZE; x++){
                                            ConnectionInstance* conn = connection_list->connectionMatrix[x][y];
                                            if (conn){
                                                PropertyValueInstance * val = value_list->valueInstances[conn->index];  //use connection idex to get the correct property
                                                if (val)
                                                    out << arrayValue(val->value, x, MAX_POPULATION_SIZE);
                                                else{
                                                    qDebug() << "Internal error: missing weightupdate property value for connection at index '" << conn->index << "' in sub synapse '" << sub_syn_name << "'.";
                                                    exit(0);
                                                }
                                            }else{
                                                //no property value
                                                out << arrayValue("0", x, MAX_POPULATION_SIZE);
                                            }
                                        }
                                        out << closeSubArray(0, y, MAX_POPULATION_SIZE) << endl;
                                    }
                                    out << closeSubArray(1, d, proj_target_sub_count) << endl;
                                    sub_syn_rows++;

                                }
                            }
                            //pad sub_syn_rows
                            for (uint x=sub_syn_rows; x< synapse->_sub_syn_max; x++){
                                out << openSubArray(1) << endl;
                                outputEmptyMatrix(MAX_POPULATION_SIZE, 2);
                                out << closeSubArray(1, x, synapse->_sub_syn_max) << endl;

                            }
                            break;
                        }
                        default:{
                            qDebug() << "Internal error: should not have explicit weightupdate properties for probablistic connections!";
                            break;
                        }

                    }//end of switch loop
                    out << "};" << endl << endl;
                }
            }
        }
    }
}

void DamsonAliasWriter::writeAllExplicitSynapseData(Population *sub_population, Population *population)
{
    uint sub_pop_index = info->getSubPopulationIndex(sub_population->neuron->name);

    for (int p=0; p<population->projections.values().size();p++ ){
        Projection *projection = population->projections.values()[p];
        ComponentInfo *target_info = info->getComponentInfo(projection->proj_population);

        //target is the named src or dst of the projection
        uint proj_target_size = target_info->size;
        uint proj_target_sub_count = UINT_DIV_CEIL(proj_target_size, MAX_POPULATION_SIZE);
        for(int s=0; s<projection->synapses.values().size(); s++){
            Synapse* synapse = projection->synapses.values()[s];
            //write connection and delay data
            writeSingleExplicitSynapseData(ALIAS_MODE_CONNECTION_DATA, projection, proj_target_sub_count, synapse, sub_population, sub_pop_index);
            if (synapse->connection->delay == NULL)
                writeSingleExplicitSynapseData(ALIAS_MODE_DELAY_DATA, projection, proj_target_sub_count, synapse, sub_population, sub_pop_index);
        }
    }
}

void DamsonAliasWriter::writeSingleExplicitSynapseData(ConnectionWriteMode mode, Projection* projection, uint proj_target_sub_count, Synapse *synapse, Population* sub_population, uint sub_pop_index)
{
    //only if no delay type is specified
    if (synapse->connection->Type() == LIST_CONNECTVITY_TYPE){                     //only for explicit list connectivity type
        QString alias_connectivity_name;
        switch (mode){
            case (ALIAS_MODE_CONNECTION_DATA):{
                alias_connectivity_name = "mainConnectionSD%1";
                break;
            }
            case(ALIAS_MODE_DELAY_DATA):{
                alias_connectivity_name = "mainDelaySD%1";
                break;
            }
        }
        alias_connectivity_name = alias_connectivity_name.arg(synapse->weightupdate->name);
        alias_connectivity_name = sanitizeName(alias_connectivity_name);
        out << alias_connectivity_name << " = {" << endl;

        uint sub_syn_rows = 0;
        for(uint d=0;d<proj_target_sub_count; d++){
            QString sub_proj_name = "%1_sub%2";
            sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);

            //get the sub projection
            if (sub_population->projections.contains(sub_proj_name)){ //may or may not be a sub projection depending on connectivity
                Projection* sub_projection = sub_population->projections[sub_proj_name];
                //get the sub synapse
                QString sub_syn_name = "%1_sub%2_%3";
                sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                //some error checking on sub synapse
                errorCheckSynapse(synapse, sub_synapse, sub_syn_name);

                //itterate all possible connections and delay value
                ConnectionList* connection_list = (ConnectionList*)sub_synapse->connection;
                out << openSubArray(1) << endl;
                for (uint y=0; y<MAX_POPULATION_SIZE; y++){
                    out << openSubArray(2);
                    for (uint x=0; x<MAX_POPULATION_SIZE; x++){
                        ConnectionInstance* conn = connection_list->connectionMatrix[x][y];
                        if (conn){
                            //output 1 (connection) or delay value
                            switch (mode){
                                case (ALIAS_MODE_CONNECTION_DATA):{
                                    out << arrayValue("1", x, MAX_POPULATION_SIZE);
                                    break;
                                }
                                case(ALIAS_MODE_DELAY_DATA):{
                                    out << arrayValue((float)conn->delay, x, MAX_POPULATION_SIZE);
                                    break;
                                }
                            }
                        }else{
                            out << arrayValue("0", x, MAX_POPULATION_SIZE);
                        }
                    }
                    out << closeSubArray(0, y, MAX_POPULATION_SIZE) << endl;

                }
                out << closeSubArray(1, d, proj_target_sub_count) << endl;
                sub_syn_rows++;
            }
        }
        //pad sub_syn_rows
        for (uint x=sub_syn_rows; x< synapse->_sub_syn_max; x++){
            out << openSubArray(1) << endl;
            outputEmptyMatrix(MAX_POPULATION_SIZE, 2);
            out << closeSubArray(1, x, synapse->_sub_syn_max) << endl;

        }
        out << "};" << endl << endl;
    }

}

void DamsonAliasWriter::writeAllExplicitNeuronInputData(Population *sub_population, Population *population)
{
    //inputs to neuron body
    for (int i=0; i<population->neuron->inputs.values().size();i++ ){
        Input *unsplit_input = population->neuron->inputs.values()[i];
        //write connection and delay matrix
        writeSingleExplicitNeuronInputData(ALIAS_MODE_CONNECTION_DATA, population->neuron->name, unsplit_input, sub_population->neuron->inputs);
        if (unsplit_input->remapping->delay == NULL)
            writeSingleExplicitNeuronInputData(ALIAS_MODE_DELAY_DATA, population->neuron->name, unsplit_input, sub_population->neuron->inputs);
    }
}

void DamsonAliasWriter::writeSingleExplicitNeuronInputData(ConnectionWriteMode mode, QString unsplit_component_name, Input *unsplit_input, QHash<QString, Input *> &split_inputs)
{
    //target is the named src of the input
    ComponentInfo *target_info = info->getComponentInfo(unsplit_input->src);
    uint input_src_size = target_info->size;
    uint input_src_sub_count = UINT_DIV_CEIL(input_src_size, MAX_POPULATION_SIZE);

    if (unsplit_input->remapping->Type() == LIST_CONNECTVITY_TYPE){                     //only for explicit list connectivity type
        QString alias_connectivity_name;
        switch (mode){
            case (ALIAS_MODE_CONNECTION_DATA):{
                alias_connectivity_name = "connectionSD%1_input_%2";
                break;
            }
            case(ALIAS_MODE_DELAY_DATA):{
                alias_connectivity_name = "delaySD%1_input_%2";
                break;
            }
        }
        alias_connectivity_name = alias_connectivity_name.arg(unsplit_component_name).arg(unsplit_input->unsplit_index+1);
        alias_connectivity_name = sanitizeName(alias_connectivity_name);
        out << alias_connectivity_name << " = {" << endl;

        uint sub_inp_rows = 0;
        for(uint d=0;d<input_src_sub_count; d++){
            QString sub_inp_name = "%1_%2_%3_sub%4";
            sub_inp_name = sub_inp_name.arg(unsplit_input->src).arg(unsplit_input->src_port).arg(unsplit_input->dst_port).arg(d);

            //get the sub projection
            if (split_inputs.contains(sub_inp_name)){ //may or may not be a sub input depending on connectivity
                Input* sub_input = split_inputs[sub_inp_name];

                //itterate all possible connections and delay value
                ConnectionList* connection_list = (ConnectionList*)sub_input->remapping;
                out << openSubArray(1) << endl;
                for (uint y=0; y<MAX_POPULATION_SIZE; y++){
                    out << openSubArray(2);
                    for (uint x=0; x<MAX_POPULATION_SIZE; x++){
                        ConnectionInstance* conn = connection_list->connectionMatrix[x][y];
                        if (conn){
                            //output 1 (connection) or delay value
                            switch (mode){
                                case (ALIAS_MODE_CONNECTION_DATA):{
                                    out << arrayValue("1", x, MAX_POPULATION_SIZE);
                                    break;
                                }
                                case(ALIAS_MODE_DELAY_DATA):{
                                    out << arrayValue((float)conn->delay, x, MAX_POPULATION_SIZE);
                                    break;
                                }
                            }
                        }else{
                            out << arrayValue("0", x, MAX_POPULATION_SIZE);
                        }
                    }
                    out << closeSubArray(0, y, MAX_POPULATION_SIZE) << endl;

                }
                out << closeSubArray(1, d, input_src_sub_count) << endl;
                sub_inp_rows++;
            }
            //pad sub_syn_rows
        }
        //pad sub_syn_rows
        for (uint x=sub_inp_rows; x< unsplit_input->sub_inp_max; x++){
            out << openSubArray(1) << endl;
            outputEmptyMatrix(MAX_POPULATION_SIZE, 2);
            out << closeSubArray(1, x, unsplit_input->sub_inp_max) << endl;

        }

        out << "};" << endl << endl;
    }
}

void DamsonAliasWriter::writeAllExplicitPSInputData(Population *sub_population, Population *population)
{
    uint sub_pop_index = info->getSubPopulationIndex(sub_population->neuron->name);

    for (int p=0; p<population->projections.values().size();p++ ){
        Projection *projection = population->projections.values()[p];
        ComponentInfo *target_info = info->getComponentInfo(projection->proj_population);

        //target is the named src or dst of the projection
        uint proj_target_size = target_info->size;
        uint proj_target_sub_count = UINT_DIV_CEIL(proj_target_size, MAX_POPULATION_SIZE);
        for(int s=0; s<projection->synapses.values().size(); s++){
            Synapse* synapse = projection->synapses.values()[s];
            for (int i=0; i<synapse->postsynapse->inputs.values().size();i++ ){
                Input *unsplit_input = synapse->postsynapse->inputs.values()[i];
                if (!((unsplit_input->src == population->neuron->name)&&(unsplit_input->remapping->Type() == ONE_TO_ONE_CONNECTVITY_TYPE))){    //ignore inputs from self if one to one (these are handled internally)
                    //write connection and delay data
                    writeSingleExplicitPSInputData(ALIAS_MODE_CONNECTION_DATA, population->neuron->name, unsplit_input, projection, proj_target_sub_count, synapse, sub_population, sub_pop_index);
                    if (unsplit_input->remapping->delay == NULL)
                        writeSingleExplicitPSInputData(ALIAS_MODE_DELAY_DATA, population->neuron->name, unsplit_input, projection, proj_target_sub_count, synapse, sub_population, sub_pop_index);
                }
            }
        }
    }
}

void DamsonAliasWriter::writeSingleExplicitPSInputData(ConnectionWriteMode mode, QString unsplit_component_name, Input *unsplit_input, Projection *projection, uint proj_target_sub_count, Synapse *synapse, Population *sub_population, uint sub_pop_index)
{
    ComponentInfo *target_info = info->getComponentInfo(unsplit_input->src);
    uint input_src_size = target_info->size;
    uint input_src_sub_count = UINT_DIV_CEIL(input_src_size, MAX_POPULATION_SIZE);

    //only if no delay type is specified
    if (unsplit_input->remapping->Type() == LIST_CONNECTVITY_TYPE){                     //only for explicit list connectivity type
        QString alias_connectivity_name;
        switch (mode){
            case (ALIAS_MODE_CONNECTION_DATA):{
                alias_connectivity_name = "connectionSD%1_input_%2";
                break;
            }
            case(ALIAS_MODE_DELAY_DATA):{
                alias_connectivity_name = "delaySD%1_input_%2";
                break;
            }
        }
        alias_connectivity_name = alias_connectivity_name.arg(unsplit_component_name).arg(unsplit_input->unsplit_index+1);
        alias_connectivity_name = sanitizeName(alias_connectivity_name);
        out << alias_connectivity_name << " = {" << endl;

        uint sub_inp_rows = 0;
        //find first sub projection to the sub population (only need the first as psps and any inputs are duplicated for any sub projection to this sub population)
        for(uint d=0;d<proj_target_sub_count; d++){
            QString sub_proj_name = "%1_sub%2";
            sub_proj_name = sub_proj_name.arg(projection->proj_population).arg(d);
            if (sub_population->projections.contains(sub_proj_name)){ //may or may not be a sub projection depending on connectivity
                Projection* sub_projection = sub_population->projections[sub_proj_name];
                //get the sub synapse
                QString sub_syn_name = "%1_sub%2_%3";
                sub_syn_name = sub_syn_name.arg(synapse->weightupdate->name).arg(sub_pop_index).arg(d);
                Synapse* sub_synapse = sub_projection->synapses[sub_syn_name];
                //some error checking on sub synapse
                errorCheckSynapse(synapse, sub_synapse, sub_syn_name);


                for(uint d=0;d<input_src_sub_count; d++){
                    QString sub_inp_name = "%1_%2_%3_sub%4";
                    sub_inp_name = sub_inp_name.arg(unsplit_input->src).arg(unsplit_input->src_port).arg(unsplit_input->dst_port).arg(d);

                    //get the sub projection
                    if (sub_synapse->postsynapse->inputs.contains(sub_inp_name)){ //may or may not be a sub input depending on connectivity
                        Input* sub_input = sub_synapse->postsynapse->inputs[sub_inp_name];

                        //itterate all possible connections and delay value
                        ConnectionList* connection_list = (ConnectionList*)sub_input->remapping;
                        out << openSubArray(1) << endl;
                        for (uint y=0; y<MAX_POPULATION_SIZE; y++){
                            out << openSubArray(2);
                            for (uint x=0; x<MAX_POPULATION_SIZE; x++){
                                ConnectionInstance* conn = connection_list->connectionMatrix[x][y];
                                if (conn){
                                    //output 1 (connection) or delay value
                                    switch (mode){
                                        case (ALIAS_MODE_CONNECTION_DATA):{
                                            out << arrayValue("1", x, MAX_POPULATION_SIZE);
                                            break;
                                        }
                                        case(ALIAS_MODE_DELAY_DATA):{
                                            out << arrayValue((float)conn->delay, x, MAX_POPULATION_SIZE);
                                            break;
                                        }
                                    }
                                }else{
                                    out << arrayValue("0", x, MAX_POPULATION_SIZE);
                                }
                            }
                            out << closeSubArray(0, y, MAX_POPULATION_SIZE) << endl;

                        }
                        out << closeSubArray(1, d, input_src_sub_count) << endl;
                        sub_inp_rows++;
                    }
                    //pad sub_syn_rows
                }
                //only need one sub projection as they all contain the same duplicated psp
                break;
            }
        }
        //pad sub_syn_rows
        for (uint x=sub_inp_rows; x< unsplit_input->sub_inp_max; x++){
            out << openSubArray(1) << endl;
            outputEmptyMatrix(MAX_POPULATION_SIZE, 2);
            out << closeSubArray(1, x, unsplit_input->sub_inp_max) << endl;

        }


        out << "};" << endl << endl;
    }

}

void DamsonAliasWriter::writeInterruptData(Population *sub_population)
{
    QSet <uint>unique_uints;
    QList <uint>ordered_uints;

    out << "clock_int: 0" << endl;
    if ((sub_population->projections.values().size() > 0) || (sub_population->neuron->inputs.values().size() > 0))
    out << "event_int: ";
    //synapse nodes
    for (int p=0; p<sub_population->projections.values().size(); p++){
        Projection * sub_proj = sub_population->projections.values()[p];
        PopulationInfo *proj_src_info = info->getUnsplitPopulationInfo(sub_proj->proj_population);
        uint proj_src_sub_index = info->getSubPopulationIndex(sub_proj->proj_population);
        uint proj_src_alias = proj_src_info->global_sub_start_index+proj_src_sub_index;
        unique_uints.insert(proj_src_alias);
    }
    //input nodes to neuron
    for (int i=0; i<sub_population->neuron->inputs.values().size(); i++){
        Input * sub_input = sub_population->neuron->inputs.values()[i];
        PopulationInfo *input_src_info = info->getUnsplitPopulationInfo(sub_input->src);
        uint input_src_sub_index = info->getSubPopulationIndex(sub_input->src);
        uint input_src_alias = input_src_info->global_sub_start_index+input_src_sub_index;
        unique_uints.insert(input_src_alias);
    }
    //write output
    ordered_uints = unique_uints.values();
    qSort(ordered_uints.begin(), ordered_uints.end());
    for (int i=0; i<ordered_uints.size(); i++){
        out << ordered_uints.at(i);
        if (i < (ordered_uints.size()-1))
                out << ", ";
    }
    out << endl << endl;
}

void DamsonAliasWriter::writeLogOutputData(Population *sub_population, Population *population, Experiment *experiment)
{
    QList <uint>ordered_uints;

    QList<LogOutput*> outputs = experiment->outputs.values(population->neuron->name);
    for (int o=0; o<outputs.size(); o++){
        LogOutput* output = outputs[o];
        bool event = false;
        //event port (for now only an event if port is a synpase input)
        for (int p=0; p<population->projections.values().size(); p++){
            Projection* projection = population->projections.values()[p];
            for (int s=0; s<projection->synapses.values().size(); s++){
                Synapse* synapse = projection->synapses.values()[s];
                if (synapse->weightupdate->input_src_port == output->port){
                    event=true;
                    break;break;
                }
            }
        }
        if (event){ //event port
            if (!output->indices.isEmpty()){
                std::cerr << "Alias Writer Warning: Indices not supported for LogOutput '" << output->name.toLocal8Bit().data() << "' on event port'" << output->port.toLocal8Bit().data() << "'" << std::endl;
            }
            out << "#snapshot \"" << sanitizeName(output->name) << "\" 0 1000000 0.000001 \"%f %d\\n\" t current_neuron_index" << endl;
        }else{ //analogue port
            uint start_index = sub_population->sub_pop_index*MAX_POPULATION_SIZE;
            uint end_index = start_index + sub_population->neuron->size;

            //build list of indices
            for (uint i=start_index; i<end_index; i++){
                if (output->indices.isEmpty() || output->indices.contains(i))
                    ordered_uints.append(i);
            }

            if (ordered_uints.size() > 0){
                out << "#log \"" << output->name << "\" ";
                out << output->start_time << " ";
                if (output->end_time == 0)
                    out << "1000000 ";
                else
                    out << output->start_time << " ";
                out << "0.000001 ";
                //printf format
                out << "\"%f ";
                for (int i=0; i<ordered_uints.size(); i++){
                    out << " %f";
                }
                out << "\\n\" ";
                //indices
                out << "t ";
                QString suffix = sanitizeName(output->target);
                for (int i=0; i<ordered_uints.size(); i++){
                    out << " " << output->port << suffix << "[" << ordered_uints.at(i) << "]";
                }
                out >> endl;

                ordered_uints.clear();
            }
        }

    }
}

void DamsonAliasWriter::errorCheckSynapse(Synapse *synapse, Synapse *sub_synapse, QString sub_syn_name)
{
    //lots of (hopefully) unnecessary error checking
    if (!sub_synapse){
        qDebug() << "Internal error: missing synapse '" << sub_syn_name << "'.";
        //exit(0);
    }
    if (sub_synapse->connection->Type() != synapse->connection->Type())
    {
        qDebug() << "Internal error: missmatched connectivity type for sub synapse '" << sub_syn_name << "' and synapse '" << synapse->weightupdate->name << "'.";
        exit(0);
    }
    //get sub property
    if (sub_synapse->weightupdate->properties.size() != synapse->weightupdate->properties.size())
    {
        qDebug() << "Internal error: missmatched number of properties for sub synapse '" << sub_syn_name << "' and synapse '" << synapse->weightupdate->name << "'.";
        exit(0);
    }

}

void DamsonAliasWriter::outputEmptyMatrix(uint dim, uint tab_depth)
{
    for (uint y=0; y<dim; y++){
        out << openSubArray(tab_depth);
        for (uint x=0; x<dim; x++){
            out << arrayValue(0.0, x, dim);
        }
        out << closeSubArray(0, y, dim) << endl;
    }
}

QString DamsonAliasWriter::openSubArray(uint depth)
{
    QString r;
    for (uint t=0; t<depth; t++)
        r = r.append("\t");
    r = r.append("{");
    return r;
}

QString DamsonAliasWriter::closeSubArray(uint depth, uint i, uint c)
{
    QString r;
    for (uint t=0; t<depth; t++)
        r = r.append("\t");
    r = r.append("}");
    if (i < (c-1))
        r = r.append(",");
    return r;
}

QString DamsonAliasWriter::sanitizeName(QString name, QString replacement)
{
    name = name.replace(" ", replacement);
    name = name.replace("-", replacement);
    return name;
}



template <class T> QString DamsonAliasWriter::arrayValue(T item, uint i, uint c){
    QString r = "%1";
    r = r.arg(item);
    if (i < (c-1))
        r = r.append(",");
    return r;

}


bool DAMSONInputHash::operator <(const DAMSONInputHash &h2) const
{
    return this->src_node_number < h2.src_node_number;
}

bool DAMSONInputHash::operator ==(const DAMSONInputHash &h2) const
{
    return (this->src_node_number==h2.src_node_number)&&(this->src_split_index == h2.src_split_index)&&(this->src_switch_value==h2.src_switch_value);
}

QString DAMSONInputHash::toString() const
{
    QString out = "{%1, %2, %3}";
    out = out.arg(this->src_node_number).arg(this->src_switch_value).arg(this->src_split_index);
    return out;
}
